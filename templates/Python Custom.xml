<templateSet group="Python Custom">
  <template name="abs_path" value="os.path.join(os.path.abspath(os.path.dirname(__file__)), '$FILE$')&#10;$END$" description="The absolute path of the current file" toReformat="false" toShortenFQNames="true">
    <variable name="FILE" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="df_to_db" value="import logging&#10;import time&#10;&#10;import numpy as np&#10;import pandas as pd&#10;from sqlalchemy import create_engine, event&#10;&#10;def sqlalchemy_conn_string(dsn=&quot;test_scotty&quot;, uid=&quot;chepdata&quot;, pwd=&quot;chep2016DATA&quot;):&#10;    conn_str = f&quot;mssql+pyodbc://{uid}:{pwd}@{dsn}&quot;&#10;    logging.debug(f&quot;createed conn_string of {conn_str}&quot;)&#10;    return conn_str&#10;&#10;&#10;def get_sqlalchemy_engine(conn_string, echo=False):&#10;    engine = create_engine(conn_string, echo=echo)&#10;&#10;    # This implements the execute many function when pd.to_sql is called to speed up exports&#10;    @event.listens_for(engine, 'before_cursor_execute')&#10;    def receive_before_cursor_execute(conn, cursor, statement, params, context, executemany):&#10;        if executemany:&#10;            cursor.fast_executemany = True&#10;&#10;    return engine&#10;&#10;&#10;def df_to_db(df, table, engine, if_exists='fail', chunksize=100000, dtype=None):&#10;    s = time.time()&#10;    df.to_sql(table, engine, if_exists=if_exists, index=False, chunksize=chunksize, dtype=dtype)&#10;    logging.info(f&quot;{time.time() - s}s to run df.to_sql with a df length of {len(df)}&quot;)&#10;" description="functions to get a df into a db" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="new_script" value="#!/usr/bin/env python&#10;&#10;&quot;&quot;&quot;Doc string short description&#10;&#10;Docstring long description&#10;&quot;&quot;&quot;&#10;&#10;import logging, logging.config&#10;import os&#10;import sys&#10;import time&#10;from pathlib import Path&#10;&#10;import pandas as pd&#10;import numpy as np&#10;import requests&#10;import yaml&#10;from pprint import pprint&#10;&#10;# if importing local packages insure src file is marked as source directory&#10;&#10;__author__ = &quot;Scotty Skidmore&quot;&#10;__created__ = &quot;$CREATED$&quot;&#10;__copyright__ = &quot;Copyright 2019, CHE Proximity&quot;&#10;__credits__ = [&quot;Scotty Skidmore&quot;]&#10;&#10;__license__ = &quot;GPL&quot;&#10;__version__ = &quot;0.0.1&quot;&#10;__maintainer__ = &quot;Scotty Skidmore&quot;&#10;__email__ = &quot;scotty.skidmore@cheproximity.com.au&quot;&#10;__status__ = &quot;Development&quot; # &quot;Development&quot;, &quot;Prototype&quot;, or &quot;Production&quot;&#10;&#10;&#10;def setup_logging(default_path, default_level=logging.INFO, env_key='LOG_CFG'):&#10;    &quot;&quot;&quot;Setup logging configuration&#10;&#10;    &quot;&quot;&quot;&#10;    path = default_path&#10;    value = os.getenv(env_key, None)&#10;    if value:&#10;        path = value&#10;    if path.exists():&#10;        with open(path, 'rt') as f:&#10;            config = yaml.safe_load(f.read())&#10;        logging.config.dictConfig(config)&#10;    else:&#10;        logging.basicConfig(level=default_level)&#10;        logging.warning('logging.yaml not imported')&#10;&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    script_start = time.time()&#10;    try:&#10;        BASE_DIR = Path(__file__).resolve().parent.parent&#10;        DATA_EXTRACT_PATH =  BASE_DIR / 'data_extract'&#10;        DATA_LOAD_PATH = BASE_DIR / 'data_load'&#10;        DATA_TRANSFORM_PATH = BASE_DIR / 'data_transform'&#10;        LOGS_PATH = BASE_DIR / 'logs'&#10;&#10;        setup_logging(LOGS_PATH / 'logging.yaml')&#10;        logging.info(&quot;__main__ start&quot;)&#10;&#10;&#10;&#10;        logging.info(&quot;__main__ end successfully&quot;)&#10;    except Exception as e:&#10;        logging.error(&quot;__main__ end with error&quot;)&#10;        raise&#10;    finally:&#10;        print(f&quot;the script took {time.time() - script_start}s to complete&quot;)" description="The basic of starting a new script" toReformat="false" toShortenFQNames="true">
    <variable name="CREATED" expression="date(&quot;yyyy-MM-dd&quot;)" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
      <option name="Python_Class" value="false" />
    </context>
  </template>
  <template name="logging_config_yaml" value="---&#10;version: 1&#10;disable_existing_loggers: False&#10;formatters:&#10;    simple:&#10;        format: &quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;&#10;    long:&#10;        format: &quot;%(asctime)s - %(levelname)s - %(name)s - %(funcName)s:%(lineno)d - %(message)s&quot;&#10;&#10;handlers:&#10;    console:&#10;        class: logging.StreamHandler&#10;        level: ERROR&#10;        formatter: long&#10;        stream: ext://sys.stdout&#10;&#10;    info_file_handler:&#10;        class: logging.handlers.RotatingFileHandler&#10;        level: INFO&#10;        formatter: long&#10;        filename: logs/info.log&#10;        maxBytes: 10485760 # 10MB&#10;        backupCount: 20&#10;        encoding: utf8&#10;&#10;    debug_file_handler:&#10;        class: logging.handlers.RotatingFileHandler&#10;        level: DEBUG&#10;        formatter: long&#10;        filename: logs/debug.log&#10;        maxBytes: 10485760 # 10MB&#10;        backupCount: 20&#10;        encoding: utf8&#10;&#10;loggers:&#10;    my_module:&#10;        level: ERROR&#10;        handlers: [console]&#10;        propagate: no&#10;&#10;root:&#10;    level: DEBUG&#10;    handlers: [console, info_file_handler, debug_file_handler]" description="The logging yaml default file" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="HTML" value="false" />
      <option name="JSON" value="false" />
      <option name="OTHER" value="true" />
      <option name="Python" value="false" />
      <option name="XML" value="false" />
    </context>
  </template>
  <template name="new_requests_functions" value="def begin_session(use_proxies=True):&#10;    proxies = {&#10;            'http': &quot;http://bc-cls03.ccla.com.au:3128&quot;,&#10;            'https': &quot;http://bc-cls03.ccla.com.au:3128&quot;,&#10;        }&#10;    session = requests.Session()&#10;    if use_proxies:&#10;        session.proxies = proxies&#10;        logging.debug('using proxies')&#10;    return session&#10;&#10;&#10;def get_url(url, session, request_type='get', verify=True):&#10;    headers = {&#10;        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36'&#10;    }&#10;    cookies = {}&#10;    data = {}&#10;&#10;    if request_type == 'get':&#10;        response = session.get(url, headers=headers, verify=verify)&#10;    elif request_type == 'post':&#10;        response = session.post(url, headers=headers, cookies=cookies, data=data, verify=verify)&#10;    else:&#10;        raise ValueError(&quot;request type has to be either 'get' or 'post'&quot;)&#10;&#10;    return response&#10;&#10;&#10;def convert_to_beautiful_soup(response):&#10;    soup = BeautifulSoup(response.text)&#10;    return soup" description="creates the functions to begin webscraping" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
</templateSet>